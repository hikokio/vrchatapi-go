/*
VRChat API Documentation


API version: 1.10.1
Contact: me@ariesclark.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vrchatapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// WorldsApiService WorldsApi service
type WorldsApiService service

type ApiCreateWorldRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	createWorldRequest *CreateWorldRequest
}

// 
func (r ApiCreateWorldRequest) CreateWorldRequest(createWorldRequest CreateWorldRequest) ApiCreateWorldRequest {
	r.createWorldRequest = &createWorldRequest
	return r
}

func (r ApiCreateWorldRequest) Execute() (*World, *http.Response, error) {
	return r.ApiService.CreateWorldExecute(r)
}

/*
CreateWorld Create World

Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWorldRequest
*/
func (a *WorldsApiService) CreateWorld(ctx context.Context) ApiCreateWorldRequest {
	return ApiCreateWorldRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return World
func (a *WorldsApiService) CreateWorldExecute(r ApiCreateWorldRequest) (*World, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *World
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.CreateWorld")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createWorldRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteWorldRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	worldId string
}

func (r ApiDeleteWorldRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWorldExecute(r)
}

/*
DeleteWorld Delete World

Delete a world. Notice a world is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The WorldID is permanently reserved.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worldId Must be a valid world ID.
 @return ApiDeleteWorldRequest
*/
func (a *WorldsApiService) DeleteWorld(ctx context.Context, worldId string) ApiDeleteWorldRequest {
	return ApiDeleteWorldRequest{
		ApiService: a,
		ctx: ctx,
		worldId: worldId,
	}
}

// Execute executes the request
func (a *WorldsApiService) DeleteWorldExecute(r ApiDeleteWorldRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.DeleteWorld")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/{worldId}"
	localVarPath = strings.Replace(localVarPath, "{"+"worldId"+"}", url.PathEscape(parameterToString(r.worldId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetActiveWorldsRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	featured *bool
	sort *SortOption
	n *int32
	order *OrderOption
	offset *int32
	search *string
	tag *string
	notag *string
	releaseStatus *ReleaseStatus
	maxUnityVersion *string
	minUnityVersion *string
	platform *string
}

// Filters on featured results.
func (r ApiGetActiveWorldsRequest) Featured(featured bool) ApiGetActiveWorldsRequest {
	r.featured = &featured
	return r
}

// The sort order of the results.
func (r ApiGetActiveWorldsRequest) Sort(sort SortOption) ApiGetActiveWorldsRequest {
	r.sort = &sort
	return r
}

// The number of objects to return.
func (r ApiGetActiveWorldsRequest) N(n int32) ApiGetActiveWorldsRequest {
	r.n = &n
	return r
}

// Result ordering
func (r ApiGetActiveWorldsRequest) Order(order OrderOption) ApiGetActiveWorldsRequest {
	r.order = &order
	return r
}

// A zero-based offset from the default object sorting from where search results start.
func (r ApiGetActiveWorldsRequest) Offset(offset int32) ApiGetActiveWorldsRequest {
	r.offset = &offset
	return r
}

// Filters by world name.
func (r ApiGetActiveWorldsRequest) Search(search string) ApiGetActiveWorldsRequest {
	r.search = &search
	return r
}

// Tags to include (comma-separated). Any of the tags needs to be present.
func (r ApiGetActiveWorldsRequest) Tag(tag string) ApiGetActiveWorldsRequest {
	r.tag = &tag
	return r
}

// Tags to exclude (comma-separated).
func (r ApiGetActiveWorldsRequest) Notag(notag string) ApiGetActiveWorldsRequest {
	r.notag = &notag
	return r
}

// Filter by ReleaseStatus.
func (r ApiGetActiveWorldsRequest) ReleaseStatus(releaseStatus ReleaseStatus) ApiGetActiveWorldsRequest {
	r.releaseStatus = &releaseStatus
	return r
}

// The maximum Unity version supported by the asset.
func (r ApiGetActiveWorldsRequest) MaxUnityVersion(maxUnityVersion string) ApiGetActiveWorldsRequest {
	r.maxUnityVersion = &maxUnityVersion
	return r
}

// The minimum Unity version supported by the asset.
func (r ApiGetActiveWorldsRequest) MinUnityVersion(minUnityVersion string) ApiGetActiveWorldsRequest {
	r.minUnityVersion = &minUnityVersion
	return r
}

// The platform the asset supports.
func (r ApiGetActiveWorldsRequest) Platform(platform string) ApiGetActiveWorldsRequest {
	r.platform = &platform
	return r
}

func (r ApiGetActiveWorldsRequest) Execute() ([]LimitedWorld, *http.Response, error) {
	return r.ApiService.GetActiveWorldsExecute(r)
}

/*
GetActiveWorlds List Active Worlds

Search and list currently Active worlds by query filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActiveWorldsRequest
*/
func (a *WorldsApiService) GetActiveWorlds(ctx context.Context) ApiGetActiveWorldsRequest {
	return ApiGetActiveWorldsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LimitedWorld
func (a *WorldsApiService) GetActiveWorldsExecute(r ApiGetActiveWorldsRequest) ([]LimitedWorld, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LimitedWorld
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.GetActiveWorlds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/active"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.featured != nil {
		localVarQueryParams.Add("featured", parameterToString(*r.featured, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.n != nil {
		localVarQueryParams.Add("n", parameterToString(*r.n, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.notag != nil {
		localVarQueryParams.Add("notag", parameterToString(*r.notag, ""))
	}
	if r.releaseStatus != nil {
		localVarQueryParams.Add("releaseStatus", parameterToString(*r.releaseStatus, ""))
	}
	if r.maxUnityVersion != nil {
		localVarQueryParams.Add("maxUnityVersion", parameterToString(*r.maxUnityVersion, ""))
	}
	if r.minUnityVersion != nil {
		localVarQueryParams.Add("minUnityVersion", parameterToString(*r.minUnityVersion, ""))
	}
	if r.platform != nil {
		localVarQueryParams.Add("platform", parameterToString(*r.platform, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFavoritedWorldsRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	featured *bool
	sort *SortOption
	n *int32
	order *OrderOption
	offset *int32
	search *string
	tag *string
	notag *string
	releaseStatus *ReleaseStatus
	maxUnityVersion *string
	minUnityVersion *string
	platform *string
	userId *string
}

// Filters on featured results.
func (r ApiGetFavoritedWorldsRequest) Featured(featured bool) ApiGetFavoritedWorldsRequest {
	r.featured = &featured
	return r
}

// The sort order of the results.
func (r ApiGetFavoritedWorldsRequest) Sort(sort SortOption) ApiGetFavoritedWorldsRequest {
	r.sort = &sort
	return r
}

// The number of objects to return.
func (r ApiGetFavoritedWorldsRequest) N(n int32) ApiGetFavoritedWorldsRequest {
	r.n = &n
	return r
}

// Result ordering
func (r ApiGetFavoritedWorldsRequest) Order(order OrderOption) ApiGetFavoritedWorldsRequest {
	r.order = &order
	return r
}

// A zero-based offset from the default object sorting from where search results start.
func (r ApiGetFavoritedWorldsRequest) Offset(offset int32) ApiGetFavoritedWorldsRequest {
	r.offset = &offset
	return r
}

// Filters by world name.
func (r ApiGetFavoritedWorldsRequest) Search(search string) ApiGetFavoritedWorldsRequest {
	r.search = &search
	return r
}

// Tags to include (comma-separated). Any of the tags needs to be present.
func (r ApiGetFavoritedWorldsRequest) Tag(tag string) ApiGetFavoritedWorldsRequest {
	r.tag = &tag
	return r
}

// Tags to exclude (comma-separated).
func (r ApiGetFavoritedWorldsRequest) Notag(notag string) ApiGetFavoritedWorldsRequest {
	r.notag = &notag
	return r
}

// Filter by ReleaseStatus.
func (r ApiGetFavoritedWorldsRequest) ReleaseStatus(releaseStatus ReleaseStatus) ApiGetFavoritedWorldsRequest {
	r.releaseStatus = &releaseStatus
	return r
}

// The maximum Unity version supported by the asset.
func (r ApiGetFavoritedWorldsRequest) MaxUnityVersion(maxUnityVersion string) ApiGetFavoritedWorldsRequest {
	r.maxUnityVersion = &maxUnityVersion
	return r
}

// The minimum Unity version supported by the asset.
func (r ApiGetFavoritedWorldsRequest) MinUnityVersion(minUnityVersion string) ApiGetFavoritedWorldsRequest {
	r.minUnityVersion = &minUnityVersion
	return r
}

// The platform the asset supports.
func (r ApiGetFavoritedWorldsRequest) Platform(platform string) ApiGetFavoritedWorldsRequest {
	r.platform = &platform
	return r
}

// Target user to see information on, admin-only.
func (r ApiGetFavoritedWorldsRequest) UserId(userId string) ApiGetFavoritedWorldsRequest {
	r.userId = &userId
	return r
}

func (r ApiGetFavoritedWorldsRequest) Execute() ([]LimitedWorld, *http.Response, error) {
	return r.ApiService.GetFavoritedWorldsExecute(r)
}

/*
GetFavoritedWorlds List Favorited Worlds

Search and list favorited worlds by query filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFavoritedWorldsRequest
*/
func (a *WorldsApiService) GetFavoritedWorlds(ctx context.Context) ApiGetFavoritedWorldsRequest {
	return ApiGetFavoritedWorldsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LimitedWorld
func (a *WorldsApiService) GetFavoritedWorldsExecute(r ApiGetFavoritedWorldsRequest) ([]LimitedWorld, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LimitedWorld
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.GetFavoritedWorlds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/favorites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.featured != nil {
		localVarQueryParams.Add("featured", parameterToString(*r.featured, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.n != nil {
		localVarQueryParams.Add("n", parameterToString(*r.n, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.notag != nil {
		localVarQueryParams.Add("notag", parameterToString(*r.notag, ""))
	}
	if r.releaseStatus != nil {
		localVarQueryParams.Add("releaseStatus", parameterToString(*r.releaseStatus, ""))
	}
	if r.maxUnityVersion != nil {
		localVarQueryParams.Add("maxUnityVersion", parameterToString(*r.maxUnityVersion, ""))
	}
	if r.minUnityVersion != nil {
		localVarQueryParams.Add("minUnityVersion", parameterToString(*r.minUnityVersion, ""))
	}
	if r.platform != nil {
		localVarQueryParams.Add("platform", parameterToString(*r.platform, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecentWorldsRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	featured *bool
	sort *SortOption
	n *int32
	order *OrderOption
	offset *int32
	search *string
	tag *string
	notag *string
	releaseStatus *ReleaseStatus
	maxUnityVersion *string
	minUnityVersion *string
	platform *string
	userId *string
}

// Filters on featured results.
func (r ApiGetRecentWorldsRequest) Featured(featured bool) ApiGetRecentWorldsRequest {
	r.featured = &featured
	return r
}

// The sort order of the results.
func (r ApiGetRecentWorldsRequest) Sort(sort SortOption) ApiGetRecentWorldsRequest {
	r.sort = &sort
	return r
}

// The number of objects to return.
func (r ApiGetRecentWorldsRequest) N(n int32) ApiGetRecentWorldsRequest {
	r.n = &n
	return r
}

// Result ordering
func (r ApiGetRecentWorldsRequest) Order(order OrderOption) ApiGetRecentWorldsRequest {
	r.order = &order
	return r
}

// A zero-based offset from the default object sorting from where search results start.
func (r ApiGetRecentWorldsRequest) Offset(offset int32) ApiGetRecentWorldsRequest {
	r.offset = &offset
	return r
}

// Filters by world name.
func (r ApiGetRecentWorldsRequest) Search(search string) ApiGetRecentWorldsRequest {
	r.search = &search
	return r
}

// Tags to include (comma-separated). Any of the tags needs to be present.
func (r ApiGetRecentWorldsRequest) Tag(tag string) ApiGetRecentWorldsRequest {
	r.tag = &tag
	return r
}

// Tags to exclude (comma-separated).
func (r ApiGetRecentWorldsRequest) Notag(notag string) ApiGetRecentWorldsRequest {
	r.notag = &notag
	return r
}

// Filter by ReleaseStatus.
func (r ApiGetRecentWorldsRequest) ReleaseStatus(releaseStatus ReleaseStatus) ApiGetRecentWorldsRequest {
	r.releaseStatus = &releaseStatus
	return r
}

// The maximum Unity version supported by the asset.
func (r ApiGetRecentWorldsRequest) MaxUnityVersion(maxUnityVersion string) ApiGetRecentWorldsRequest {
	r.maxUnityVersion = &maxUnityVersion
	return r
}

// The minimum Unity version supported by the asset.
func (r ApiGetRecentWorldsRequest) MinUnityVersion(minUnityVersion string) ApiGetRecentWorldsRequest {
	r.minUnityVersion = &minUnityVersion
	return r
}

// The platform the asset supports.
func (r ApiGetRecentWorldsRequest) Platform(platform string) ApiGetRecentWorldsRequest {
	r.platform = &platform
	return r
}

// Target user to see information on, admin-only.
func (r ApiGetRecentWorldsRequest) UserId(userId string) ApiGetRecentWorldsRequest {
	r.userId = &userId
	return r
}

func (r ApiGetRecentWorldsRequest) Execute() ([]LimitedWorld, *http.Response, error) {
	return r.ApiService.GetRecentWorldsExecute(r)
}

/*
GetRecentWorlds List Recent Worlds

Search and list recently visited worlds by query filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecentWorldsRequest
*/
func (a *WorldsApiService) GetRecentWorlds(ctx context.Context) ApiGetRecentWorldsRequest {
	return ApiGetRecentWorldsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LimitedWorld
func (a *WorldsApiService) GetRecentWorldsExecute(r ApiGetRecentWorldsRequest) ([]LimitedWorld, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LimitedWorld
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.GetRecentWorlds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/recent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.featured != nil {
		localVarQueryParams.Add("featured", parameterToString(*r.featured, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.n != nil {
		localVarQueryParams.Add("n", parameterToString(*r.n, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.notag != nil {
		localVarQueryParams.Add("notag", parameterToString(*r.notag, ""))
	}
	if r.releaseStatus != nil {
		localVarQueryParams.Add("releaseStatus", parameterToString(*r.releaseStatus, ""))
	}
	if r.maxUnityVersion != nil {
		localVarQueryParams.Add("maxUnityVersion", parameterToString(*r.maxUnityVersion, ""))
	}
	if r.minUnityVersion != nil {
		localVarQueryParams.Add("minUnityVersion", parameterToString(*r.minUnityVersion, ""))
	}
	if r.platform != nil {
		localVarQueryParams.Add("platform", parameterToString(*r.platform, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorldRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	worldId string
}

func (r ApiGetWorldRequest) Execute() (*World, *http.Response, error) {
	return r.ApiService.GetWorldExecute(r)
}

/*
GetWorld Get World by ID

Get information about a specific World.
Works unauthenticated but when so will always return `0` for certain fields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worldId Must be a valid world ID.
 @return ApiGetWorldRequest
*/
func (a *WorldsApiService) GetWorld(ctx context.Context, worldId string) ApiGetWorldRequest {
	return ApiGetWorldRequest{
		ApiService: a,
		ctx: ctx,
		worldId: worldId,
	}
}

// Execute executes the request
//  @return World
func (a *WorldsApiService) GetWorldExecute(r ApiGetWorldRequest) (*World, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *World
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.GetWorld")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/{worldId}"
	localVarPath = strings.Replace(localVarPath, "{"+"worldId"+"}", url.PathEscape(parameterToString(r.worldId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorldInstanceRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	worldId string
	instanceId string
}

func (r ApiGetWorldInstanceRequest) Execute() (*Instance, *http.Response, error) {
	return r.ApiService.GetWorldInstanceExecute(r)
}

/*
GetWorldInstance Get World Instance

Returns a worlds instance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worldId Must be a valid world ID.
 @param instanceId Must be a valid instance ID.
 @return ApiGetWorldInstanceRequest
*/
func (a *WorldsApiService) GetWorldInstance(ctx context.Context, worldId string, instanceId string) ApiGetWorldInstanceRequest {
	return ApiGetWorldInstanceRequest{
		ApiService: a,
		ctx: ctx,
		worldId: worldId,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return Instance
func (a *WorldsApiService) GetWorldInstanceExecute(r ApiGetWorldInstanceRequest) (*Instance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Instance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.GetWorldInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/{worldId}/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"worldId"+"}", url.PathEscape(parameterToString(r.worldId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorldMetadataRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	worldId string
}

func (r ApiGetWorldMetadataRequest) Execute() (*WorldMetadata, *http.Response, error) {
	return r.ApiService.GetWorldMetadataExecute(r)
}

/*
GetWorldMetadata Get World Metadata

Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worldId Must be a valid world ID.
 @return ApiGetWorldMetadataRequest

Deprecated
*/
func (a *WorldsApiService) GetWorldMetadata(ctx context.Context, worldId string) ApiGetWorldMetadataRequest {
	return ApiGetWorldMetadataRequest{
		ApiService: a,
		ctx: ctx,
		worldId: worldId,
	}
}

// Execute executes the request
//  @return WorldMetadata
// Deprecated
func (a *WorldsApiService) GetWorldMetadataExecute(r ApiGetWorldMetadataRequest) (*WorldMetadata, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorldMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.GetWorldMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/{worldId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"worldId"+"}", url.PathEscape(parameterToString(r.worldId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorldPublishStatusRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	worldId string
}

func (r ApiGetWorldPublishStatusRequest) Execute() (*WorldPublishStatus, *http.Response, error) {
	return r.ApiService.GetWorldPublishStatusExecute(r)
}

/*
GetWorldPublishStatus Get World Publish Status

Returns a worlds publish status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worldId Must be a valid world ID.
 @return ApiGetWorldPublishStatusRequest
*/
func (a *WorldsApiService) GetWorldPublishStatus(ctx context.Context, worldId string) ApiGetWorldPublishStatusRequest {
	return ApiGetWorldPublishStatusRequest{
		ApiService: a,
		ctx: ctx,
		worldId: worldId,
	}
}

// Execute executes the request
//  @return WorldPublishStatus
func (a *WorldsApiService) GetWorldPublishStatusExecute(r ApiGetWorldPublishStatusRequest) (*WorldPublishStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorldPublishStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.GetWorldPublishStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/{worldId}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"worldId"+"}", url.PathEscape(parameterToString(r.worldId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishWorldRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	worldId string
}

func (r ApiPublishWorldRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublishWorldExecute(r)
}

/*
PublishWorld Publish World

Publish a world. You can only publish one world per week.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worldId Must be a valid world ID.
 @return ApiPublishWorldRequest
*/
func (a *WorldsApiService) PublishWorld(ctx context.Context, worldId string) ApiPublishWorldRequest {
	return ApiPublishWorldRequest{
		ApiService: a,
		ctx: ctx,
		worldId: worldId,
	}
}

// Execute executes the request
func (a *WorldsApiService) PublishWorldExecute(r ApiPublishWorldRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.PublishWorld")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/{worldId}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"worldId"+"}", url.PathEscape(parameterToString(r.worldId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchWorldsRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	featured *bool
	sort *SortOption
	user *string
	userId *string
	n *int32
	order *OrderOption
	offset *int32
	search *string
	tag *string
	notag *string
	releaseStatus *ReleaseStatus
	maxUnityVersion *string
	minUnityVersion *string
	platform *string
}

// Filters on featured results.
func (r ApiSearchWorldsRequest) Featured(featured bool) ApiSearchWorldsRequest {
	r.featured = &featured
	return r
}

// The sort order of the results.
func (r ApiSearchWorldsRequest) Sort(sort SortOption) ApiSearchWorldsRequest {
	r.sort = &sort
	return r
}

// Set to &#x60;me&#x60; for searching own worlds.
func (r ApiSearchWorldsRequest) User(user string) ApiSearchWorldsRequest {
	r.user = &user
	return r
}

// Filter by UserID.
func (r ApiSearchWorldsRequest) UserId(userId string) ApiSearchWorldsRequest {
	r.userId = &userId
	return r
}

// The number of objects to return.
func (r ApiSearchWorldsRequest) N(n int32) ApiSearchWorldsRequest {
	r.n = &n
	return r
}

// Result ordering
func (r ApiSearchWorldsRequest) Order(order OrderOption) ApiSearchWorldsRequest {
	r.order = &order
	return r
}

// A zero-based offset from the default object sorting from where search results start.
func (r ApiSearchWorldsRequest) Offset(offset int32) ApiSearchWorldsRequest {
	r.offset = &offset
	return r
}

// Filters by world name.
func (r ApiSearchWorldsRequest) Search(search string) ApiSearchWorldsRequest {
	r.search = &search
	return r
}

// Tags to include (comma-separated). Any of the tags needs to be present.
func (r ApiSearchWorldsRequest) Tag(tag string) ApiSearchWorldsRequest {
	r.tag = &tag
	return r
}

// Tags to exclude (comma-separated).
func (r ApiSearchWorldsRequest) Notag(notag string) ApiSearchWorldsRequest {
	r.notag = &notag
	return r
}

// Filter by ReleaseStatus.
func (r ApiSearchWorldsRequest) ReleaseStatus(releaseStatus ReleaseStatus) ApiSearchWorldsRequest {
	r.releaseStatus = &releaseStatus
	return r
}

// The maximum Unity version supported by the asset.
func (r ApiSearchWorldsRequest) MaxUnityVersion(maxUnityVersion string) ApiSearchWorldsRequest {
	r.maxUnityVersion = &maxUnityVersion
	return r
}

// The minimum Unity version supported by the asset.
func (r ApiSearchWorldsRequest) MinUnityVersion(minUnityVersion string) ApiSearchWorldsRequest {
	r.minUnityVersion = &minUnityVersion
	return r
}

// The platform the asset supports.
func (r ApiSearchWorldsRequest) Platform(platform string) ApiSearchWorldsRequest {
	r.platform = &platform
	return r
}

func (r ApiSearchWorldsRequest) Execute() ([]LimitedWorld, *http.Response, error) {
	return r.ApiService.SearchWorldsExecute(r)
}

/*
SearchWorlds Search All Worlds

Search and list any worlds by query filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchWorldsRequest
*/
func (a *WorldsApiService) SearchWorlds(ctx context.Context) ApiSearchWorldsRequest {
	return ApiSearchWorldsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LimitedWorld
func (a *WorldsApiService) SearchWorldsExecute(r ApiSearchWorldsRequest) ([]LimitedWorld, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LimitedWorld
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.SearchWorlds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.featured != nil {
		localVarQueryParams.Add("featured", parameterToString(*r.featured, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.n != nil {
		localVarQueryParams.Add("n", parameterToString(*r.n, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.notag != nil {
		localVarQueryParams.Add("notag", parameterToString(*r.notag, ""))
	}
	if r.releaseStatus != nil {
		localVarQueryParams.Add("releaseStatus", parameterToString(*r.releaseStatus, ""))
	}
	if r.maxUnityVersion != nil {
		localVarQueryParams.Add("maxUnityVersion", parameterToString(*r.maxUnityVersion, ""))
	}
	if r.minUnityVersion != nil {
		localVarQueryParams.Add("minUnityVersion", parameterToString(*r.minUnityVersion, ""))
	}
	if r.platform != nil {
		localVarQueryParams.Add("platform", parameterToString(*r.platform, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnpublishWorldRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	worldId string
}

func (r ApiUnpublishWorldRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnpublishWorldExecute(r)
}

/*
UnpublishWorld Unpublish World

Unpublish a world.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worldId Must be a valid world ID.
 @return ApiUnpublishWorldRequest
*/
func (a *WorldsApiService) UnpublishWorld(ctx context.Context, worldId string) ApiUnpublishWorldRequest {
	return ApiUnpublishWorldRequest{
		ApiService: a,
		ctx: ctx,
		worldId: worldId,
	}
}

// Execute executes the request
func (a *WorldsApiService) UnpublishWorldExecute(r ApiUnpublishWorldRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.UnpublishWorld")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/{worldId}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"worldId"+"}", url.PathEscape(parameterToString(r.worldId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateWorldRequest struct {
	ctx context.Context
	ApiService *WorldsApiService
	worldId string
	updateWorldRequest *UpdateWorldRequest
}

func (r ApiUpdateWorldRequest) UpdateWorldRequest(updateWorldRequest UpdateWorldRequest) ApiUpdateWorldRequest {
	r.updateWorldRequest = &updateWorldRequest
	return r
}

func (r ApiUpdateWorldRequest) Execute() (*World, *http.Response, error) {
	return r.ApiService.UpdateWorldExecute(r)
}

/*
UpdateWorld Update World

Update information about a specific World.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worldId Must be a valid world ID.
 @return ApiUpdateWorldRequest
*/
func (a *WorldsApiService) UpdateWorld(ctx context.Context, worldId string) ApiUpdateWorldRequest {
	return ApiUpdateWorldRequest{
		ApiService: a,
		ctx: ctx,
		worldId: worldId,
	}
}

// Execute executes the request
//  @return World
func (a *WorldsApiService) UpdateWorldExecute(r ApiUpdateWorldRequest) (*World, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *World
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorldsApiService.UpdateWorld")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worlds/{worldId}"
	localVarPath = strings.Replace(localVarPath, "{"+"worldId"+"}", url.PathEscape(parameterToString(r.worldId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateWorldRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
